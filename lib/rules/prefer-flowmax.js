// Generated by CoffeeScript 2.4.1
(function() {
  var getFlowToFlowMaxFixer, isBranchPure, isFlow, isFunction, isMagic, isNonmagicHelper, shouldFix,
    indexOf = [].indexOf;

  ({isFlow, isMagic, isBranchPure, getFlowToFlowMaxFixer, isNonmagicHelper, isFunction, shouldFix} = require('../util'));

  module.exports = {
    meta: {
      docs: {
        description: 'Flag flow() calls that could be converted to flowMax()',
        category: 'Possible Errors',
        recommended: true
      },
      schema: [
        {
          enum: ['always',
        'whenUsingUnknownHelpers']
        }
      ],
      fixable: 'code'
    },
    create: function(context) {
      var helperRegex, isHelper, isPotentiallyMagicCustomHelper, isWhitelisted, ref, ref1, ref2, regexMatchingHelpers, report, settings, variant, whitelist;
      variant = (ref = context.options[0]) != null ? ref : 'always';
      ({settings} = context);
      whitelist = (ref1 = settings['ad-hok/nonmagic-helper-whitelist']) != null ? ref1 : [];
      helperRegex = (ref2 = settings['ad-hok/possibly-magic-helper-regex']) != null ? ref2 : 'add.*';
      isWhitelisted = function(name) {
        return indexOf.call(whitelist, name) >= 0;
      };
      regexMatchingHelpers = new RegExp(helperRegex);
      isPotentiallyMagicCustomHelper = function(argument) {
        var name, ref3, ref4;
        if (argument == null) {
          return false;
        }
        name = (ref3 = (ref4 = argument.callee) != null ? ref4.name : void 0) != null ? ref3 : argument.name;
        if (name == null) {
          return false;
        }
        if (isWhitelisted(name)) {
          return false;
        }
        return regexMatchingHelpers.test(name);
      };
      isHelper = function(argument) {
        if (argument == null) {
          return false;
        }
        if (argument.type === 'Identifier') {
          return true;
        }
        if (argument.type !== 'CallExpression') {
          return false;
        }
        return argument.callee.type === 'Identifier';
      };
      report = function(node) {
        return context.report({
          node,
          message: "Use flowMax() instead",
          fix: shouldFix({context}) ? getFlowToFlowMaxFixer({node, context}) : null
        });
      };
      return {
        CallExpression: function(node) {
          var argument, checkArgument, i, len, ref3, shouldReturn;
          if (!isFlow(node)) {
            return;
          }
          if (variant === 'always') {
            return report(node);
          }
          checkArgument = function(argument) {
            var branchPureArgument, i, len, ref3, shouldReturn;
            if (argument == null) {
              return {};
            }
            // don't overlap with needs-flowmax
            if (isMagic(argument)) {
              return {
                shouldReturn: true
              };
            }
            if (isNonmagicHelper(argument)) {
              if (isBranchPure(argument)) {
                ref3 = argument.arguments;
                for (i = 0, len = ref3.length; i < len; i++) {
                  branchPureArgument = ref3[i];
                  ({shouldReturn} = checkArgument(branchPureArgument));
                  if (shouldReturn) {
                    return {
                      shouldReturn: true
                    };
                  }
                }
              }
              return {};
            }
            if (isPotentiallyMagicCustomHelper(argument)) {
              report(node);
              return {
                shouldReturn: true
              };
            }
            if (argument.type === 'ConditionalExpression') {
              if (isPotentiallyMagicCustomHelper(argument.consequent) || isPotentiallyMagicCustomHelper(argument.alternate)) {
                report(node);
                return {
                  shouldReturn: true
                };
              }
            }
            return {};
          };
          ref3 = node.arguments;
          for (i = 0, len = ref3.length; i < len; i++) {
            argument = ref3[i];
            ({shouldReturn} = checkArgument(argument));
            if (shouldReturn) {
              return;
            }
          }
        }
      };
    }
  };

}).call(this);
