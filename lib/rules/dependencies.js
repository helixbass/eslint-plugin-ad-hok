// Generated by CoffeeScript 2.4.1
(function() {
  var getFunctionParam, helperNames,
    indexOf = [].indexOf;

  helperNames = ['addProps', 'addEffect', 'addHandlers', 'addStateHandlers'];

  getFunctionParam = function(argumentNum) {
    return function(func) {
      var ref;
      if ((func != null ? func.type : void 0) !== 'ArrowFunctionExpression') {
        return;
      }
      return (ref = func.params[argumentNum]) != null ? ref : {
        type: 'ObjectPattern',
        properties: []
      };
    };
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Flag missing/unnecessary dependencies',
        category: 'Possible Errors',
        recommended: true
      },
      schema: []
    },
    create: function(context) {
      var reportMissing, reportUnused;
      reportUnused = function(node) {
        return context.report({
          node,
          message: `Unnecessary dependency "${node.value}"`
        });
      };
      reportMissing = function(node, name) {
        return context.report({
          node,
          message: `Missing dependency "${name}"`
        });
      };
      return {
        CallExpression: function(node) {
          var args, callee, dependencies, dependency, dependencyParam, dependencyParams, handlers, i, j, k, key, l, len, len1, len2, len3, name, property, ref, ref1, ref2, results, rootDependencies, rootDependency, usedDependencies, usedDependency, value;
          ({
            callee,
            arguments: args
          } = node);
          if ((callee != null ? callee.type : void 0) !== 'Identifier') {
            return;
          }
          ({name} = callee);
          if (indexOf.call(helperNames, name) < 0) {
            return;
          }
          switch (name) {
            case 'addHandlers':
              dependencies = args[1];
              handlers = args[0];
              if ((handlers != null ? handlers.type : void 0) !== 'ObjectExpression') {
                return;
              }
              dependencyParams = (function() {
                var i, len, ref, results;
                ref = handlers.properties;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                  property = ref[i];
                  ({value} = property);
                  results.push(getFunctionParam(0)(value));
                }
                return results;
              })();
              break;
            case 'addStateHandlers':
              dependencies = args[2];
              handlers = args[1];
              if ((handlers != null ? handlers.type : void 0) !== 'ObjectExpression') {
                return;
              }
              dependencyParams = (function() {
                var i, len, ref, results;
                ref = handlers.properties;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                  property = ref[i];
                  ({value} = property);
                  results.push(getFunctionParam(1)(value));
                }
                return results;
              })();
              break;
            default:
              dependencies = args[1];
              dependencyParams = [getFunctionParam(0)(args[0])];
          }
          if (!((dependencies != null ? dependencies.type : void 0) === 'ArrayExpression' && (dependencyParams != null ? dependencyParams.length : void 0))) {
            return;
          }
          usedDependencies = [];
          for (i = 0, len = dependencyParams.length; i < len; i++) {
            dependencyParam = dependencyParams[i];
            if ((dependencyParam != null ? dependencyParam.type : void 0) !== 'ObjectPattern') {
              return;
            }
            ref = dependencyParam.properties;
            for (j = 0, len1 = ref.length; j < len1; j++) {
              property = ref[j];
              if (property.type !== 'Property') {
                return;
              }
              ({key} = property);
              if (key.type !== 'Identifier') {
                return;
              }
              if (ref1 = key.name, indexOf.call(usedDependencies, ref1) < 0) {
                usedDependencies.push(key.name);
              }
            }
          }
          ref2 = dependencies.elements;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            dependency = ref2[k];
            if (dependency.type !== 'Literal') {
              return;
            }
            ({value} = dependency);
            rootDependency = value.split('.')[0];
            if (indexOf.call(usedDependencies, rootDependency) < 0) {
              reportUnused(dependency);
            }
          }
          rootDependencies = (function() {
            var l, len3, ref3, results;
            ref3 = dependencies.elements;
            results = [];
            for (l = 0, len3 = ref3.length; l < len3; l++) {
              dependency = ref3[l];
              results.push(dependency.value.split('.')[0]);
            }
            return results;
          })();
          results = [];
          for (l = 0, len3 = usedDependencies.length; l < len3; l++) {
            usedDependency = usedDependencies[l];
            if (indexOf.call(rootDependencies, usedDependency) < 0) {
              results.push(reportMissing(node, usedDependency));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    }
  };

}).call(this);
